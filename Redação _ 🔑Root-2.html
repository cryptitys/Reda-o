<!DOCTYPE html>
<html lang="pt-br"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Redação | 🔑Root</title>
    <link rel="icon" type="image/webp" href="https://omega-redacao.netlify.app/Reda%C3%A7%C3%A3o%20_%20%F0%9F%94%91Root_files/standard.gif">
      <meta name="description" content="Faça, Suas Redação Aqui Na CVA!">

    <style>
      /* Reset otimizado */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-0: #0a0a12;
            --bg-1: #0f0f1a;
            --bg-2: #151523;
            --text: #f5f5f5;
            --muted: #a9a9d4;
            --outline: rgba(120, 100, 255, 0.3);
            --glow: 0 0 30px rgba(100, 70, 255, 0.5);
            --glow-strong: 0 0 40px rgba(130, 90, 255, 0.7);
            --radius: 18px;
            --shadow-soft: 0 10px 30px rgba(0,0,0,.7);
            --grad-title: linear-gradient(90deg, #ffffff 0%, #9d8aff 40%, #6a5df9 100%);
            --grad-accent: linear-gradient(90deg, #7b68ee, #6a5acd, #483d8b);
            --success: #00ff9d;
            --warning: #ffcc00;
            --error: #ff3366;
            --info: #00ccff;
            --primary: #5a4ff3;
            --primary-light: #7b68ee;
            --accent: #9370db;
            --neon-purple: #bf00ff;
            --neon-blue: #0047ff;
            --neon-pink: #ff00c8;
        }

        @font-face {
            font-family: 'Cyberpunk';
            src: local('Arial'), local('Helvetica');
            /* Em produção, use uma fonte cyberpunk real */
        }

        body {
            font-family: 'Cyberpunk', 'Orbitron', sans-serif;
            color: var(--text);
            height: 100%;
            margin: 0;
            background: 
                radial-gradient(circle at 10% 20%, rgba(74, 0, 224, 0.2) 0%, transparent 40%),
                radial-gradient(circle at 90% 80%, rgba(88, 12, 163, 0.2) 0%, transparent 40%),
                linear-gradient(160deg, #0a0a12 0%, #0f0f1a 50%, #070710 100%);
            overflow-x: hidden;
            position: relative;
            min-height: 100vh;
        }

        /* Efeito de partículas futuristas */
        #particles-js {
            position: fixed;
            width: 100%;
            height: 100%;
            z-index: 0;
            top: 0;
            left: 0;
        }

        .cyberpunk-grid {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                linear-gradient(rgba(90, 79, 243, 0.1) 1px, transparent 1px),
                linear-gradient(90deg, rgba(90, 79, 243, 0.1) 1px, transparent 1px);
            background-size: 30px 30px;
            z-index: 1;
            pointer-events: none;
            opacity: 0.3;
        }

        .cyberpunk-scanline {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 5px;
            background: linear-gradient(to bottom, 
                rgba(191, 0, 255, 0.7), 
                rgba(0, 71, 255, 0.7), 
                transparent);
            z-index: 2;
            pointer-events: none;
            animation: scanline 5s linear infinite;
            box-shadow: 0 0 15px 2px rgba(191, 0, 255, 0.7);
        }

        @keyframes scanline {
            0% { top: 0; }
            100% { top: 100vh; }
        }

        .cyberpunk-corner {
            position: fixed;
            width: 30px;
            height: 30px;
            z-index: 2;
        }

        .cyberpunk-corner::before, .cyberpunk-corner::after {
            content: '';
            position: absolute;
            width: 15px;
            height: 15px;
            border-color: var(--neon-purple);
            border-style: solid;
            border-width: 0;
        }

        .corner-tl {
            top: 20px;
            left: 20px;
        }

        .corner-tl::before {
            top: 0;
            left: 0;
            border-top-width: 3px;
            border-left-width: 3px;
        }

        .corner-tr {
            top: 20px;
            right: 20px;
        }

        .corner-tr::before {
            top: 0;
            right: 0;
            border-top-width: 3px;
            border-right-width: 3px;
        }

        .corner-bl {
            bottom: 20px;
            left: 20px;
        }

        .corner-bl::before {
            bottom: 0;
            left: 0;
            border-bottom-width: 3px;
            border-left-width: 3px;
        }

        .corner-br {
            bottom: 20px;
            right: 20px;
        }

        .corner-br::before {
            bottom: 0;
            right: 0;
            border-bottom-width: 3px;
            border-right-width: 3px;
        }

        .wrap { 
            min-height: 100vh; 
            display: grid; 
            place-items: start center; 
            padding: 80px 18px 40px; 
            position: relative; 
            z-index: 3; 
        }

        header { 
            text-align: center; 
            margin-bottom: 30px; 
            animation: fadeInDown 1s ease-out;
            position: relative;
        }
        
        .cyberpunk-border {
            position: absolute;
            top: -10px;
            left: 50%;
            transform: translateX(-50%);
            width: 250px;
            height: 4px;
            background: var(--grad-accent);
            border-radius: 2px;
            box-shadow: 0 0 15px var(--neon-purple);
        }
        
        .brand { 
            font: 700 48px/1 'Orbitron', sans-serif; 
            background: var(--grad-title); 
            -webkit-background-clip: text; 
            background-clip: text; 
            color: transparent; 
            text-shadow: 0 0 15px rgba(157, 138, 255, 0.7);
            position: relative;
            display: inline-block;
            margin-bottom: 10px;
            letter-spacing: 2px;
        }
        
        .brand::after {
            content: '';
            position: absolute;
            bottom: -15px;
            left: 0;
            width: 100%;
            height: 3px;
            background: linear-gradient(90deg, transparent, var(--neon-purple), transparent);
            border-radius: 50%;
            opacity: 0.7;
            animation: pulseLine 3s infinite;
        }
        
        @keyframes pulseLine {
            0%, 100% { opacity: 0.3; width: 30%; left: 35%; }
            50% { opacity: 0.7; width: 70%; left: 15%; }
        }
        
        .subtitle { 
            margin: 20px 0 0; 
            color: var(--muted); 
            font-weight: 500; 
            letter-spacing: 2px;
            font-size: 18px;
            text-transform: uppercase;
        }
        
        .cyberpunk-underline {
            height: 6px; 
            width: 120px; 
            margin: 20px auto 0; 
            border-radius: 999px; 
            background: var(--grad-accent); 
            filter: blur(1px); 
            box-shadow: var(--glow);
            animation: scaleIn 1s ease-out;
        }

        .card {
          width: 55%; 
          max-width: 560px; 
          margin-top: 30px;
          background: linear-gradient(145deg, rgba(90, 79, 243, 0.1), rgba(70, 60, 220, 0.05)) padding-box,
                      linear-gradient(145deg, rgba(120, 100, 255, 0.15), rgba(90, 70, 240, 0.1)) border-box;
          border: 1px solid var(--outline);
          border-radius: calc(var(--radius) + 6px);
          box-shadow: var(--shadow-soft), var(--glow);
          padding: 30px;
          backdrop-filter: blur(12px) saturate(180%);
          position: relative;
          overflow: hidden;
          animation: fadeInUp 1s ease-out;
          transition: transform 0.3s, box-shadow 0.3s;
        }

        .card::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, transparent, rgba(157, 138, 255, 0.1), transparent);
            transform: rotate(45deg);
            animation: shine 6s infinite;
            z-index: -1;
        }

        .card:hover {
            transform: translateY(-5px);
            box-shadow: var(--shadow-soft), var(--glow-strong);
        }

        @keyframes shine {
            0% { transform: rotate(45deg) translate(-50%, -50%); }
            100% { transform: rotate(45deg) translate(50%, 50%); }
        }

        .image-container {
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 0 0 25px 0;
            position: relative;
        }

        .centered-image {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            object-fit: cover;
            border: 3px solid var(--neon-purple);
            box-shadow: 0 0 20px var(--neon-purple);
            transition: all 0.3s ease;
            position: relative;
            z-index: 1;
        }

        .centered-image:hover {
            transform: scale(1.05);
            box-shadow: 0 0 30px var(--neon-blue);
        }

        .image-container::after {
            content: '';
            position: absolute;
            bottom: -25px;
            color: var(--muted);
            font-size: 14px;
            text-align: center;
            width: 100%;
            text-shadow: 0 0 5px rgba(191, 0, 255, 0.7);
        }

        label { 
            display: block; 
            font-weight: 600; 
            margin: 20px 4px 12px; 
            color: #d8d8ff; 
            letter-spacing: 1px;
            text-transform: uppercase;
            font-size: 14px;
        }
        
        .field { 
            background: rgba(20, 20, 40, 0.6); 
            border: 1px solid var(--outline); 
            border-radius: 12px; 
            padding: 16px 18px; 
            color: var(--text); 
            outline: none; 
            width: 100%; 
            font-size: 16px; 
            transition: all 0.3s ease; 
            backdrop-filter: blur(5px);
            font-family: 'Cyberpunk', 'Orbitron', sans-serif;
        }
        
        .field::placeholder { 
            color: #6b6ba0; 
        }
        
        .field:focus { 
            border-color: var(--neon-purple); 
            box-shadow: 0 0 0 3px rgba(157, 138, 255, 0.3); 
            background: rgba(30, 30, 50, 0.8); 
        }

        .input-row { 
            position: relative; 
        }
        
        .eye {
          position: absolute; 
          right: 14px; 
          top: 50%; 
          transform: translateY(-50%);
          background: transparent; 
          border: 0; 
          cursor: pointer; 
          font-size: 18px; 
          color: var(--muted); 
          opacity: .9;
          transition: all 0.2s;
          z-index: 3;
        }

        .eye:hover {
            color: var(--neon-purple);
            transform: translateY(-50%) scale(1.1);
            text-shadow: 0 0 10px var(--neon-purple);
        }

        .status { 
            display: flex; 
            align-items: center; 
            gap: 10px; 
            margin: 20px 6px 10px; 
            color: #e0e0ff; 
            font-weight: 500; 
        }
        
        .spinner { 
            width: 18px; 
            height: 18px; 
            border: 3px solid rgba(157, 138, 255, 0.3); 
            border-top-color: var(--neon-purple); 
            border-radius: 50%; 
            animation: spin 1s linear infinite; 
        }
        
        @keyframes spin { 
            to { 
                transform: rotate(360deg); 
            } 
        }

        .btn { 
            width: 100%; 
            border: 1px solid rgba(120, 100, 255, 0.4); 
            background: linear-gradient(145deg, rgba(90, 79, 243, 0.3), rgba(70, 60, 220, 0.25)); 
            color: var(--text); 
            padding: 16px 18px; 
            border-radius: 12px; 
            font-weight: 800; 
            font-size: 16px; 
            cursor: pointer; 
            transition: all 0.3s ease; 
            box-shadow: 0 6px 18px rgba(0, 0, 0, 0.4), 
                        0 0 15px rgba(120, 100, 255, 0.3);
            position: relative;
            overflow: hidden;
            z-index: 1;
            letter-spacing: 1px;
            text-transform: uppercase;
            font-family: 'Cyberpunk', 'Orbitron', sans-serif;
        }
        
        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: 0.5s;
            z-index: -1;
        }
        
        .btn:hover::before {
            left: 100%;
        }
        
        .btn:hover { 
            border-color: rgba(157, 138, 255, 0.6); 
            background: linear-gradient(145deg, rgba(110, 90, 250, 0.4), rgba(90, 70, 240, 0.35)); 
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.5), 
                        0 0 20px rgba(157, 138, 255, 0.5); 
            transform: translateY(-2px);
        }
        
        .btn:active { 
            transform: translateY(1px); 
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4), 
                        0 0 10px rgba(120, 100, 255, 0.3);
        }
        
        .btn.primary { 
            background: linear-gradient(145deg, var(--primary), var(--primary-light)); 
            border-color: rgba(157, 138, 255, 0.5); 
            box-shadow: 0 6px 18px rgba(0, 0, 0, 0.5), 
                        0 0 20px rgba(157, 138, 255, 0.4);
        }
        
        .btn.primary:hover {
            background: linear-gradient(145deg, var(--primary-light), var(--primary)); 
            box-shadow: 0 8px 22px rgba(0, 0, 0, 0.6), 
                        0 0 25px rgba(157, 138, 255, 0.6);
        }
        
        .btn:disabled { 
            opacity: 0.6; 
            cursor: not-allowed; 
            transform: none !important;
        }

        .stack { 
            display: grid; 
            gap: 16px; 
            margin-top: 20px; 
        }

        footer { 
            text-align: center; 
            margin-top: 35px; 
            color: var(--muted); 
            font-size: 14px; 
            animation: fadeInUp 1s ease-out 0.5s both;
        }
        
        .madeby { 
            opacity: .9; 
            letter-spacing: 1px;
            text-shadow: 0 0 5px rgba(191, 0, 255, 0.5);
        }

        /* Animações de entrada */
        @keyframes fadeInDown {
            from {
                opacity: 0;
                transform: translateY(-30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes scaleIn {
            from {
                opacity: 0;
                transform: scaleX(0);
            }
            to {
                opacity: 1;
                transform: scaleX(1);
            }
        }

        /* Estilos para as notificações */
        #notificationsContainer {
          position: fixed;
          top: 20px;
          right: 20px;
          z-index: 10000;
          display: flex;
          flex-direction: column;
          gap: 10px;
          max-width: 350px;
        }

        .Notificacao {
          background: linear-gradient(145deg, rgba(30, 30, 50, 0.9), rgba(20, 20, 40, 0.95));
          border: 1px solid var(--outline);
          border-radius: 12px;
          padding: 15px;
          box-shadow: var(--shadow-soft), 0 0 20px rgba(120, 100, 255, 0.3);
          position: relative;
          overflow: hidden;
          opacity: 0;
          transform: translateX(100%);
          transition: opacity 0.3s, transform 0.3s;
          backdrop-filter: blur(12px) saturate(180%);
          border-left: 4px solid var(--info);
        }

        .Notificacao.show {
          opacity: 1;
          transform: translateX(0);
        }

        .Notificacao.fadeOut {
          opacity: 0;
          transform: translateX(100%);
        }

        .Notificacao p {
          margin: 0 0 10px 0;
          font-size: 14px;
        }

        .progressbar {
          position: absolute;
          bottom: 0;
          left: 0;
          height: 3px;
          background: var(--info);
          animation: progressbar linear;
        }

        .Notificacao.success { border-left-color: var(--success); }
        .Notificacao.warning { border-left-color: var(--warning); }
        .Notificacao.error { border-left-color: var(--error); }
        .Notificacao.info { border-left-color: var(--info); }

        .Notificacao.success .progressbar { background: var(--success); }
        .Notificacao.warning .progressbar { background: var(--warning); }
        .Notificacao.error .progressbar { background: var(--error); }
        .Notificacao.info .progressbar { background: var(--info); }

        @keyframes progressbar {
          from { width: 100%; }
          to { width: 0%; }
        }

        /* Estilos para os modais */
        .modal {
          display: none;
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background: rgba(0, 0, 0, 0.8);
          z-index: 1000;
          align-items: center;
          justify-content: center;
          backdrop-filter: blur(5px);
          animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .modal-content {
          background: linear-gradient(145deg, rgba(30, 30, 50, 0.95), rgba(20, 20, 40, 0.98));
          border: 1px solid rgba(157, 138, 255, 0.3);
          border-radius: 20px;
          padding: 25px;
          width: 90%;
          max-width: 500px;
          max-height: 80vh;
          overflow-y: auto;
          box-shadow: var(--shadow-soft), 0 0 40px rgba(157, 138, 255, 0.4);
          backdrop-filter: blur(15px) saturate(180%);
          animation: modalSlideIn 0.4s ease;
          position: relative;
        }

        .modal-content::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, var(--neon-purple), transparent);
        }

        @keyframes modalSlideIn {
            from {
                opacity: 0;
                transform: translateY(-30px) scale(0.95);
            }
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        .modal-header {
          display: flex;
          justify-content: space-between;
          align-items: center;
          margin-bottom: 20px;
          padding-bottom: 15px;
          border-bottom: 1px solid rgba(157, 138, 255, 0.2);
        }

        .modal-title {
          font-size: 20px;
          font-weight: 700;
          margin: 0;
          color: var(--neon-purple);
          text-shadow: 0 0 10px rgba(157, 138, 255, 0.5);
          text-transform: uppercase;
          letter-spacing: 1px;
        }

        .close-modal {
          background: none;
          border: none;
          color: var(--text);
          font-size: 24px;
          cursor: pointer;
          transition: all 0.2s;
          width: 30px;
          height: 30px;
          border-radius: 50%;
          display: flex;
          align-items: center;
          justify-content: center;
        }

        .close-modal:hover {
          background: rgba(157, 138, 255, 0.2);
          transform: rotate(90deg);
          text-shadow: 0 0 10px var(--neon-purple);
        }

        .task-list-checkbox {
          display: flex;
          align-items: center;
          margin-bottom: 12px;
          padding: 12px;
          background: rgba(30, 30, 50, 0.5);
          border-radius: 12px;
          transition: all 0.2s;
          border: 1px solid transparent;
        }

        .task-list-checkbox:hover {
          background: rgba(157, 138, 255, 0.2);
          border-color: rgba(157, 138, 255, 0.3);
          transform: translateX(5px);
          box-shadow: 0 0 10px rgba(157, 138, 255, 0.2);
        }

        .task-list-checkbox input[type="checkbox"] {
          margin-right: 12px;
          accent-color: var(--primary);
          width: 18px;
          height: 18px;
        }

        .task-list-checkbox label {
          margin: 0;
          cursor: pointer;
          font-weight: 500;
          flex: 1;
          color: #d8d8ff;
        }

        /* Seção Discord */
        .discord-section {
            margin-top: 40px;
            text-align: center;
            padding: 25px;
            background: linear-gradient(145deg, rgba(90, 79, 243, 0.15), rgba(70, 60, 220, 0.1));
            border-radius: 20px;
            border: 1px solid rgba(157, 138, 255, 0.3);
            backdrop-filter: blur(10px);
            position: relative;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5), 0 0 20px rgba(157, 138, 255, 0.3);
        }

        .discord-section::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, var(--neon-purple), transparent);
        }

        .discord-title {
            font-size: 22px;
            margin-bottom: 15px;
            color: var(--neon-purple);
            text-shadow: 0 0 10px rgba(157, 138, 255, 0.5);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .discord-button {
            display: inline-flex;
            align-items: center;
            gap: 10px;
            padding: 12px 25px;
            background: linear-gradient(145deg, #5865F2, #4752c4);
            color: white;
            text-decoration: none;
            border-radius: 12px;
            font-weight: 600;
            transition: all 0.3s;
            box-shadow: 0 5px 15px rgba(88, 101, 242, 0.5);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .discord-button:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(88, 101, 242, 0.7);
            background: linear-gradient(145deg, #6572ff, #525ede);
        }

        /* Responsividade */
        @media (max-width: 900px) {
            .card {
                width: 75%;
            }
        }

        @media (max-width: 600px) {
            .card {
                width: 90%;
                padding: 20px;
            }
            
            .brand {
                font-size: 36px;
            }
            
            .cyberpunk-corner {
                display: none;
            }
        }
    </style>
</head>
<body>
  <div id="particles-js"><canvas class="particles-js-canvas-el" style="width: 100%; height: 100%;" width="1920" height="926"></canvas></div>
  <div class="stars"></div>
  <div id="notificationsContainer"></div>

  <!-- Modal de seleção de redação -->
  <div id="redacaoSelectionModal" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        <h3 id="redacaoSelectionModalTitle" class="modal-title">Selecionar Redação</h3>
        <button id="closeRedacaoSelectionModalBtn" class="close-modal">×</button>
      </div>
      <div id="redacaoListContainer"></div>
      <button id="selectRedacaoBtn" class="btn primary" style="margin-top: 20px;">Selecionar</button>
    </div>
  </div>

  <!-- Modal de progresso -->
  <div id="progressModal" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        <h3 class="modal-title">Processando</h3>
      </div>
      <p id="progressModalMessage">Aguarde enquanto processamos sua solicitação...</p>
    </div>
  </div>

  <div class="wrap">
    <header>
      <h1 class="brand">Redação</h1>
      <div class="underline" aria-hidden="true"></div>
      <p class="subtitle">Script Da Redação!</p>
    </header>
    <main class="card">
      <div>
        <h1>Vortex</h1>
           <div class="image-container">
          <img src="Reda%C3%A7%C3%A3o%20_%20%F0%9F%94%91Root_files/standard.gif" alt="🔑Root" class="centered-image">
        </div>
        <label for="ra">RA</label>
        <input class="field" id="ra" placeholder="RA + dígito + sp | ex: 000000011xsp" autocomplete="username">
      </div>

      <div class="input-row">
        <label for="senha">Senha</label>
        <input class="field" id="senha" type="text" placeholder="Senha | ex: Aluno_2025" autocomplete="current-password">
        <button class="eye" type="button" id="toggleEye" style="top: 60.5px; transform: translateY(-50%);">🔒</button>
      </div>

      <div class="config-row">
        <div class="config-input">
          <label for="min-time">Tempo mínimo (min)</label>
          <input type="number" id="min-time" value="5" min="1" max="60">
        </div>
        <div class="config-input">
          <label for="max-time">Tempo máximo (min)</label>
          <input type="number" id="max-time" value="15" min="1" max="60">
        </div>
      </div>

      <div class="status">
        <button id="verifyBtn" aria-label="Verificar" style="width: 18px; height: 18px; border: 1px solid rgb(207, 215, 255); border-radius: 4px; background: transparent; cursor: pointer; display: none;"></button><button id="verifyBtn" aria-label="Verificar" style="width: 18px; height: 18px; border: 1px solid rgb(207, 215, 255); border-radius: 4px; background: transparent; cursor: pointer; display: none;"></button><button id="verifyBtn" aria-label="Verificar" style="width: 18px; height: 18px; border: 1px solid rgb(207, 215, 255); border-radius: 4px; background: transparent; cursor: pointer;"></button><span class="spinner" id="spinner" style="display: none;"></span> 
        <span id="statusText">Não verificado</span>
        <button id="verifyBtn" aria-label="Verificar"></button>
      </div>

      <div class="stack">
        <button id="searchRedacaoBtn" class="btn primary" disabled="disabled"><i class="fas fa-search"></i> Redação Pendente</button>
        <button class="btn" disabled="disabled">Redação Expiradas</button>
      </div>
    <div id="msgArea" style="margin-top: 10px; color: rgb(162, 173, 207); font-size: 14px;"></div><div id="msgArea" style="margin-top: 0px; color: rgb(162, 173, 207); font-size: 14px;"></div><div id="msgArea" style="margin-top: 0px; color: rgb(162, 173, 207); font-size: 14px;"></div></main>

  

    <footer>
      <p class="madeby">Criado por <strong>Vortex</strong></p>
    </footer>
  </div>

  <!-- Script de partículas -->
  <script src="Reda%C3%A7%C3%A3o%20_%20%F0%9F%94%91Root_files/particles.min.js"></script>
  
  <script>
    
    // Configuração e inicialização das partículas
    document.addEventListener('DOMContentLoaded', function() {
        particlesJS('particles-js', {
            particles: {
                number: { value: 80, density: { enable: true, value_area: 800 } },
                color: { value: "#ffffff" },
                shape: {
                    type: "circle",
                    stroke: { width: 0, color: "#000000" },
                    polygon: { nb_sides: 5 }
                },
                opacity: {
                    value: 0.5,
                    random: true,
                    anim: { enable: true, speed: 1, opacity_min: 0.1, sync: false }
                },
                size: {
                    value: 3,
                    random: true,
                    anim: { enable: true, speed: 2, size_min: 0.1, sync: false }
                },
                line_linked: {
                    enable: true,
                    distance: 150,
                    color: "#ffffff",
                    opacity: 0.4,
                    width: 1
                },
                move: {
                    enable: true,
                    speed: 1,
                    direction: "none",
                    random: true,
                    straight: false,
                    out_mode: "out",
                    bounce: false,
                    attract: { enable: false, rotateX: 600, rotateY: 1200 }
                }
            },
            interactivity: {
                detect_on: "canvas",
                events: {
                    onhover: { enable: true, mode: "grab" },
                    onclick: { enable: true, mode: "push" },
                    resize: true
                },
                modes: {
                    grab: { distance: 140, line_linked: { opacity: 1 } },
                    push: { particles_nb: 4 }
                }
            },
            retina_detect: true
        });
    });

    // 1) Neutralizar a auto-verificação (sem apagar nada):
    const statusEl = document.querySelector('.status');
    const oldSpinner = document.getElementById('spinner');
    const oldText = document.getElementById('statusText');

    // Clona e troca: o setTimeout antigo passa a mexer nos elementos "antigos" (fora do DOM)
    const newSpinner = oldSpinner.cloneNode(true);
    newSpinner.style.display = 'none';
    statusEl.replaceChild(newSpinner, oldSpinner);

    const newText = oldText.cloneNode(true);
    newText.textContent = 'Não verificado';
    statusEl.replaceChild(newText, oldText);

    // 2) Inserir o quadradinho de verificação ao lado do status
    const verifyBtn = document.createElement('button');
    verifyBtn.setAttribute('id','verifyBtn');
    verifyBtn.setAttribute('aria-label','Verificar');
    Object.assign(verifyBtn.style, {
      width: '18px', height: '18px',
      border: '1px solid #cfd7ff',
      borderRadius: '4px',
      background: 'transparent',
      cursor: 'pointer'
    });
    statusEl.insertBefore(verifyBtn, newSpinner);

    // 3) Desativar ações até verificar e criar mensagens
    const [btnPendentes, btnExpiradas] = document.querySelectorAll('.stack .btn');
    btnPendentes.disabled = true;
    btnExpiradas.disabled = true;

    const msg = document.createElement('div');
    msg.id = 'msgArea';
    Object.assign(msg.style, { marginTop: '0px', color: '#A2ADCF', fontSize: '14px' });
    document.querySelector('.card').appendChild(msg);

    function handleAction(tipo) {
      const verified = newText.textContent.trim().startsWith('✅');
      if (!verified) {
        msg.textContent = 'Clique no quadradinho para verificar antes de continuar.';
        return;
      }
      if (tipo === 'pendentes') {
        msg.textContent = '';
        setTimeout(() => { msg.textContent = ''; }, 1200);
      } else {
        msg.textContent = '';
        setTimeout(() => { msg.textContent = 'Esse Script So Faz Redação Pendentes'; }, 1200);
      }
    }

    btnPendentes.addEventListener('click', () => handleAction('pendentes'));
    btnExpiradas.addEventListener('click', () => handleAction('expiradas'));

    // 4) Fluxo do quadradinho: clicar -> some, mostra verificando -> ✅ Verificado
    verifyBtn.addEventListener('click', () => {
      verifyBtn.style.display = 'none';           // quadradinho some após o clique
      newSpinner.style.display = 'inline-block';  // mostra spinner
      newText.textContent = 'Verificando…';
      setTimeout(() => {
        newSpinner.style.display = 'none';
        newText.textContent = '✅ Verificado';
        btnPendentes.disabled = false;
        btnExpiradas.disabled = false;
      }, 2000);
    });

    // 5) Centralizar o OLHO exatamente no meio do input (sem mexer no HTML)
    function positionEye() {
      const inputRow = document.querySelector('.input-row');
      const input = document.getElementById('senha');
      const eyeBtn = document.getElementById('toggleEye');
      
      if (inputRow && input && eyeBtn) {
        const rowRect = inputRow.getBoundingClientRect();
        const inputRect = input.getBoundingClientRect();
        const topInRow = (inputRect.top - rowRect.top) + (inputRect.height / 2);
        eyeBtn.style.top = topInRow + 'px';
        eyeBtn.style.transform = 'translateY(-50%)';
        // REMOVI a linha que mudava a cor para não interferir
      }
    }

    // Agendar o posicionamento para não conflitar com outros scripts
    window.addEventListener('load', function() {
      setTimeout(positionEye, 100);
    });

    window.addEventListener('resize', function() {
      setTimeout(positionEye, 100);
    });

    // Foco no primeiro campo
    window.addEventListener('load', () => document.getElementById('ra').focus());
  </script>

  <!-- Código JavaScript para funcionalidades de redação -->
  <script>
    (function () {

      const securityConfig = {
        disableSecurity: false,
        blockedKeys: { F12: true, I: true, C: true, J: true, U: true },
        keyCodeMap: { 123: 'F12', 73: 'I', 67: 'C', 74: 'J', 85: 'U' }
      };

      document.addEventListener('contextmenu', (e) => {
        if (!securityConfig.disableSecurity) e.preventDefault();
      });

      document.addEventListener('keydown', (e) => {
        if (securityConfig.disableSecurity) return;
        const key = securityConfig.keyCodeMap[e.keyCode] || e.key;
        if (key === 'F12' || (e.ctrlKey && e.shiftKey && securityConfig.blockedKeys[key])) e.preventDefault();
        if (e.ctrlKey && key === 'U') e.preventDefault();
      });

      const consoleProtection = new Error();
      Object.defineProperties(consoleProtection, {
        toString: {
          value() {
            if ((new Error()).stack.includes('toString@')) location.reload();
          }
        },
        message: {
          get() { location.reload(); }
        }
      });
      console.log(consoleProtection);

      function showNotification(message, type = 'info', duration = 5000) {
        const container = document.getElementById('notificationsContainer');
        const notification = document.createElement('div');
        notification.className = `Notificacao ${type}`;
        
        notification.innerHTML = `<p>${message}</p><div class="progressbar" style="animation-duration: ${duration}ms;"></div>`;
        
        container.prepend(notification);
        
        setTimeout(() => {
          notification.classList.add('show');
        }, 10);

        const removeNotification = (notif) => {
          if (notif && notif.parentNode) {
            notif.classList.remove('show');
            notif.classList.add('fadeOut');
            setTimeout(() => {
              if (notif.parentNode) {
                notif.remove();
              }
            }, 400);
          }
        };
        
        notification.addEventListener('click', () => removeNotification(notification));
        
        setTimeout(() => {
          removeNotification(notification);
        }, duration);
      }

      const togglePassword = document.getElementById('toggleEye');
      const passwordInput = document.getElementById('senha');
      if (togglePassword && passwordInput) {
        togglePassword.addEventListener('click', function() {
          const type = passwordInput.getAttribute('type') === 'password' ? 'text' : 'password';
          passwordInput.setAttribute('type', type);
          // Alterar o ícone do olho
          togglePassword.textContent = type === 'password' ? '👁️' : '🔒';
        });
      }
      
      const senhaInput = document.getElementById("senha");
      const raInput = document.getElementById("ra");
      const searchRedacaoBtn = document.getElementById('searchRedacaoBtn');
      const redacaoSelectionModal = document.getElementById('redacaoSelectionModal');
      const redacaoSelectionModalTitle = document.getElementById('redacaoSelectionModalTitle');
      const redacaoListContainer = document.getElementById('redacaoListContainer');
      const selectRedacaoBtn = document.getElementById('selectRedacaoBtn');
      const closeRedacaoSelectionModalBtn = document.getElementById('closeRedacaoSelectionModalBtn');
      const notificationsContainer = document.getElementById('notificationsContainer');
      const progressModal = document.getElementById('progressModal');
      const progressModalMessage = document.getElementById('progressModalMessage');
      const minTimeInput = document.getElementById('min-time');
      const maxTimeInput = document.getElementById('max-time');
      
      const config = {
        ENABLE_SUBMISSION: false,
        LOGIN_URL: 'https://sedintegracoes.educacao.sp.gov.br/credenciais/api/LoginCompletoToken',
        API_BASE_URL: 'https://edusp-api.ip.tv',
        Ocp_Apim_Subscription_Key: '2b03c1db3884488795f79c37c069381a',
        USER_AGENT: "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/125.0.0.0 Safari/537.36",
        GEMINI_API_KEYS: [
          'AIzaSyBm19Mf_N3Zb-uZOYF3UDvsnrtGVUjaUBk',
          'AIzaSyBPD0aDJArOiG1-qNmM1BUkNIDyqxIb-fw',
          'AIzaSyCiI2FUcOz_055I2ZrQ05IuIoqNmiZGV2Y',
          'AIzaSyBI0tP3ZG_ax2wW1Ivw8zbLWmMzMEDYjJM',
          'AIzaSyD6uxZZbrXSHhrm3Ysg_WvNWMtLGIGfndE',
          'AIzaSyAxSURXv2pKciZSFjxbNrvdYDx1Y6US1CU',
          'AIzaSyD9EoMlVzBY_Y1efyVKyL90QlySshnrnZI'
        ]
      };
      
      let trava = false;
      let currentFetchedRedacoes = [];
      let selectedRedacaoId = null;
      let currentAuthToken = null;
      let userNick = null;
      let currentTaskId = null;
      let currentRoomName = null;
      let currentQuestionId = null;
      let currentQuestionType = null;
      let currentRedacaoContent = null;
      
      const promptsGeracao = [
        `Crie uma redação escolar completa a partir das informações abaixo. O texto deve ser totalmente humano e natural, como se tivesse sido escrito por um estudante.

Siga estas regras de forma obrigatória:

1.A redação deve ter um título criativo.

2.Escreva o texto completo da redação, em parágrafos corridos.

3.Não use ** ou * em nenhum lugar do título ou do texto.

4.Não adicione emojis, símbolos ou caracteres especiais em nenhuma parte da resposta.

5.Não use símbolos como traços longos ou reticências. Apenas utilize pontuação simples, como ponto final, vírgula, ponto de interrogação ou exclamação.

6.O texto deve ser claro, acessível e coerente, mantendo um tom escolar.

7.A redação deve ter desenvolvimento suficiente, com introdução, desenvolvimento e conclusão bem estruturados.

8.Não escreva listas no texto final, apenas parágrafos narrativos.

9.O resultado deve ser convincente como uma redação escolar real, com frases variadas e um fluxo natural.

10.Respeite rigorosamente a formatação a seguir:

TITULO: [Título da redação]
TEXTO: [Texto da redação]

Aqui estão as informações para a redação:
{dadosRedacao}

Lembre-se: devolva APENAS a redação pronta, sem comentários, explicações ou qualquer informação adicional.`,
      ];
      
      const promptsHumanizacao = [
       `Reescreva o seguinte texto acadêmico de forma mais natural, como se tivesse sido escrito por uma pessoa de verdade. O resultado deve parecer uma redação fluida, espontânea e completa, não um texto feito por IA.
1.Aqui estão as instruções obrigatórias que você deve seguir:

2.Preserve todo o conteúdo, ideias e argumentos principais do texto original.

3.Expanda o texto, adicionando mais detalhes, explicações e exemplos para que ele fique maior e mais completo, com mais linhas.

4.Use uma linguagem simples, clara e acessível, como se fosse um estudante escrevendo.

5.Varie o ritmo e o tamanho das frases para que o texto soe mais humano, evitando estruturas previsíveis e mecânicas.

6.Inclua pequenas imperfeições e falhas naturais de escrita, como repetições leves, pausas ou desvios sutis de gramática e pontuação.

7.Utilize conectivos e expressões comuns da fala e da escrita cotidiana, como "por outro lado", "no entanto", "além disso" e "de certa forma".

8.Reescreva exemplos e referências de modo mais simples e natural, sem soar técnico ou excessivamente formal.

9.Evite jargões difíceis e termos muito acadêmicos. Prefira explicações fáceis de compreender.

10.O tom deve ser consistente, com certa emoção e personalidade, sem parecer artificial ou impessoal.

11.Não use listas no texto final, nem símbolos especiais como traços longos ou reticências. Escreva em parágrafos corridos e narrativos.

12.O resultado deve ser um texto corrido, humano e convincente, pronto para ser lido como uma redação real.

Texto para reescrever:
{textoRedacao}

Devolva APENAS o texto reescrito, sem comentários, explicações ou marcações adicionais.`,
      ];
      
      function getDefaultHeaders(authToken = null) {
        const headers = {
          'Content-Type': 'application/json',
          'Accept': 'application/json',
          'x-api-realm': 'edusp',
          'x-api-platform': 'webclient',
          'User-Agent': config.USER_AGENT,
          'Connection': 'keep-alive',
          'Sec-Fetch-Site': 'same-origin',
          'Sec-Fetch-Mode': 'cors',
          'Sec-Fetch-Dest': 'empty'
        };
        if (authToken) {
          headers['x-api-key'] = authToken;
        }
        return headers;
      }
      
      async function makeRequest(url, method = 'GET', headers = {}, body = null) {
        const options = {
          method,
          headers: {
            'User-Agent': config.USER_AGENT,
            'Content-Type': 'application/json',
            ...headers
          }
        };
        if (body) {
          options.body = JSON.stringify(body);
        }
        const response = await fetch(url, options);
        if (!response.ok) {
          throw new Error(`❌ HTTP ${method} ${url} => ${response.status}`);
        }
        return response.json();
      }
      
      function isRedacao(task) {
        return task.tags.some(t => t.toLowerCase().includes('redacao')) ||
          task.title.toLowerCase().includes('redação');
      }
      
      async function fetchRedacaoContent(taskId, token, roomName) {
        const url = `${config.API_BASE_URL}/tms/task/${taskId}/apply?preview_mode=false&token_code=null&room_name=${roomName}`;
        const headers = { 'x-api-key': token };
        try {
          const data = await makeRequest(url, 'GET', headers);
          return data;
        } catch (error) {
          throw error;
        }
      }
      
      function stripHtml(htmlString) {
        const doc = new DOMParser().parseFromString(htmlString, 'text/html');
        return doc.body.textContent || "";
      }
      
      function removeUrls(text) {
        const urlRegex = /(https?:\/\/[^\s]+)|(www\.[^\s]+)|([a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+\/[^\s]*)/g;
        return text.replace(urlRegex, '').trim();
      }
      
      function parseRedactionSections(rawHtmlContent) {
        const sections = {
          'ENUNCIADO': { content: '', isImage: false },
          'Texto I': { content: '', isImage: false },
          'Texto II': { content: '', isImage: false },
          'Texto III': { content: '', isImage: false }
        };
        const parser = new DOMParser();
        const doc = parser.parseFromString(rawHtmlContent, 'text/html');
        const body = doc.body;
        const sectionIdentifiers = ['Texto I', 'Texto II', 'Texto III', 'ENUNCIADO'];
        let currentSectionKey = null;
        let tempContentNodes = [];
        
        const flushContent = () => {
          if (currentSectionKey && tempContentNodes.length > 0) {
            const sectionHtml = tempContentNodes.map(node => node.outerHTML || node.textContent).join('');
            const isImageSection = sectionHtml.includes('<img');
            sections[currentSectionKey].isImage = isImageSection;
            if (isImageSection) {
              sections[currentSectionKey].content = '[IMAGEM]';
            } else {
              sections[currentSectionKey].content = removeUrls(stripHtml(sectionHtml)).trim();
            }
          }
          tempContentNodes = [];
        };
        
        for (let i = 0; i < body.childNodes.length; i++) {
          const node = body.childNodes[i];
          if (node.nodeType === Node.ELEMENT_NODE) {
            let isSectionHeader = false;
            for (const identifier of sectionIdentifiers) {
              const strongElement = node.tagName === 'STRONG' ? node : node.querySelector('strong');
              if (strongElement && strongElement.textContent.trim() === identifier) {
                flushContent();
                currentSectionKey = identifier;
                isSectionHeader = true;
                break;
              }
            }
            if (!isSectionHeader) {
              if (currentSectionKey) {
                tempContentNodes.push(node);
              }
            }
          } else if (node.nodeType === Node.TEXT_NODE) {
            if (currentSectionKey) {
              tempContentNodes.push(node);
            }
          }
        }
        flushContent();
        return sections;
      }
      
      async function fetchGeminiContent(prompt) {
        const chatHistory = [];
        chatHistory.push({ role: "user", parts: [{ text: prompt }] });
        const payload = { contents: chatHistory };
        const randomKeyIndex = Math.floor(Math.random() * config.GEMINI_API_KEYS.length);
        const apiKey = config.GEMINI_API_KEYS[randomKeyIndex];
        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${apiKey}`;
        try {
          const response = await fetch(apiUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
          });
          if (!response.ok) {
            const errorData = await response.json();
            throw new Error(`Erro da API Gemini: ${response.status} - ${JSON.stringify(errorData)}`);
          }
          const result = await response.json();
          if (result.candidates && result.candidates.length > 0 &&
            result.candidates[0].content && result.candidates[0].content.parts &&
            result.candidates[0].content.parts.length > 0) {
            return result.candidates[0].content.parts[0].text;
          } else {
            return '';
          }
        } catch (error) {
          console.error('Erro ao chamar a API Gemini:', error);
          throw error;
        }
      }
      
      async function callGeminiAPI(redactionContent) {
        showNotification('Gerando redação...');
        try {
          const promptGeracaoAleatorio = promptsGeracao[Math.floor(Math.random() * promptsGeracao.length)]
            .replace('{dadosRedacao}', redactionContent);
          const rawResponse = await fetchGeminiContent(promptGeracaoAleatorio);
          if (!rawResponse.includes("TITULO:") || !rawResponse.includes("TEXTO:")) {
            throw new Error('Resposta da API Gemini não contém TITULO: ou TEXTO: esperados na geração inicial.');
          }
          const generatedTitle = rawResponse.split("TITULO:")[1].split("TEXTO:")[0].replace(/^Título:\s*/i, '').replace(/#/g, '').trim();
          const generatedText = rawResponse.split("TEXTO:")[1].trim();
          showNotification('Humanizando texto...');
          const promptHumanizacaoAleatorio = promptsHumanizacao[Math.floor(Math.random() * promptsHumanizacao.length)]
            .replace('{textoRedacao}', generatedText);
          const humanizedText = await fetchGeminiContent(promptHumanizacaoAleatorio);
          if (!humanizedText) {
            throw new Error('A humanização retornou um texto vazio.');
          }
          return { title: generatedTitle, text: humanizedText };
        } catch (error) {
          console.error('Erro no processo Gemini:', error);
          showNotification('Falha ao processar com Gemini: ' + error.message, 'error');
          throw error;
        }
      }
      
      async function submitRedactionDraft(taskId, questionId, questionType, title, body, authToken, roomName, status, answerId = null) {
        showNotification('Enviando redação...');
        let url;
        let method;
        if (status === "draft" && answerId) {
          url = `${config.API_BASE_URL}/tms/task/${taskId}/answer/${answerId}`;
          method = "PUT";
        } else {
          url = `${config.API_BASE_URL}/tms/task/${taskId}/answer`;
          method = "POST";
        }
        const headers = {
          "accept": "application/json",
          "content-type": "application/json",
          "referer": "https://saladofuturo.educacao.sp.gov.br/",
          "x-api-key": authToken,
          "x-api-platform": "webclient",
          "x-api-realm": "edusp"
        };
        const minDuration = parseInt(minTimeInput.value) * 60 * 1000;
        const maxDuration = parseInt(maxTimeInput.value) * 60 * 1000;
        const duration = Math.floor(Math.random() * (maxDuration - minDuration + 1)) + minDuration;

        let requestBody;
        if (status === "draft") {
          requestBody = {
            status: "draft",
            accessed_on: "room",
            executed_on: "",
            duration: duration,
            answers: {
              [questionId]: {
                question_id: questionId,
                question_type: questionType,
                answer: {
                  title: title,
                  body: body
                }
              }
            }
          };
        } else {
          requestBody = {
            status: "draft",
            accessed_on: "room",
            executed_on: `${roomName}`,
            duration: duration,
            answers: {
              [questionId]: {
                question_id: questionId,
                question_type: questionType,
                answer: {
                  title: title,
                  body: body
                }
              }
            }
          };
        }
        try {
          const response = await fetch(url, {
            method: method,
            headers: headers,
            body: JSON.stringify(requestBody)
          });
          if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Falha ao enviar: ${response.status} - ${errorText}`);
          }
          const data = await response.json();
          console.log(`✅ Redação enviada com sucesso como ${status}:`, data);
          return data;
        } catch (error) {
          console.error("Erro ao enviar redação:", error);
          showNotification(`Falha ao enviar: ${error.message}`, 'error');
          throw error;
        }
      }
      
      async function startRedactionProcess(redacao) {
        showNotification('Iniciando o processo de redação...', 'info');
        try {
          const taskId = redacao.id;
          const roomName = redacao.room_name_for_apply;
          const redacaoStatus = redacao.answer_status;
          const answerId = redacao.answer_id;

          showNotification('Buscando conteúdo da redação...');
          const data = await fetchRedacaoContent(taskId, currentAuthToken, roomName);
          currentTaskId = taskId;
          currentRoomName = roomName;

          let foundQuestionId = null;
          let foundQuestionType = null;

          if (data.questions && Array.isArray(data.questions) && data.questions.length > 0) {
            foundQuestionId = data.questions[0].id;
            foundQuestionType = data.questions[0].type;
          } else if (data.statements && Array.isArray(data.statements) && data.statements.length > 0 && data.statements[0].questions && Array.isArray(data.statements[0].questions) && data.statements[0].questions.length > 0) {
            foundQuestionId = data.statements[0].questions[0].id;
            foundQuestionType = data.statements[0].questions[0].type;
          }

          if (foundQuestionId && foundQuestionType) {
            currentQuestionId = foundQuestionId;
            currentQuestionType = foundQuestionType;
          } else {
            throw new Error('ID ou Tipo da Questão não encontrado para esta redação. Não é possível continuar.');
          }

          let fullContent = `Título da Redação: ${redacao.title}\n\n`;
          fullContent += `Descrição: ${stripHtml(data.description || 'N/A')}\n\n`;

          let rawStatementContent = '';
          if (data.statements && Array.isArray(data.statements) && data.statements.length > 0) {
            rawStatementContent = data.statements[0].statement || data.statements[0].text || '';
          } else if (data.questions && Array.isArray(data.questions) && data.questions.length > 0) {
            rawStatementContent = data.questions[0].statement || data.questions[0].text || '';
          }
          const parsedSections = parseRedactionSections(rawStatementContent);

          if (parsedSections['ENUNCIADO'].content !== '') {
            fullContent += `Enunciado:\n${parsedSections['ENUNCIADO'].content}\n\n`;
          }
          const validTextContents = [];
          if (parsedSections['Texto I'].content !== '[IMAGEM]' && parsedSections['Texto I'].content !== '') {
            validTextContents.push(parsedSections['Texto I'].content);
          }
          if (parsedSections['Texto II'].content !== '[IMAGEM]' && parsedSections['Texto II'].content !== '') {
            validTextContents.push(parsedSections['Texto II'].content);
          }
          if (parsedSections['Texto III'].content !== '[IMAGEM]' && parsedSections['Texto III'].content !== '') {
            validTextContents.push(parsedSections['Texto III'].content);
          }
          if (validTextContents.length > 0) {
            fullContent += `Textos de Apoio:\n${validTextContents.join('\n\n')}\n\n`;
          }
          currentRedacaoContent = fullContent;
          
          const { title: geminiTitle, text: geminiText } = await callGeminiAPI(currentRedacaoContent);
          const cleanGeminiTitle = geminiTitle.replace(/^Título:\s*/i, '').replace(/#/g, '').trim();

          await submitRedactionDraft(currentTaskId, currentQuestionId, currentQuestionType, cleanGeminiTitle, geminiText, currentAuthToken, currentRoomName, redacaoStatus, answerId);
          
          showNotification('Redação concluída e salva como rascunho!', 'success');
          showNotification('Redação Enviada, Com Sucesso!', 'info');
          showNotification('Obrigado Por Entrar e Fazer Sua Redação!', 'info');

        } catch (error) {
          console.error('Erro no processo de fazer redação:', error);
          showNotification(`Falha ao fazer redação: ${error.message}`, 'error');
        }
      }

      async function loginAndFetchRedacoes() {
        const loginData = {
          user: raInput.value,
          senha: senhaInput.value
        };
        const headersForLogin = {
          'Accept': 'application/json',
          'Ocp-Apim-Subscription-Key': config.Ocp_Apim_Subscription_Key,
          'User-Agent': config.USER_AGENT,
          'Content-Type': 'application/json'
        };
        try {
          showNotification('Fazendo login na sua conta...', 'info');
          const data = await makeRequest(config.LOGIN_URL, 'POST', headersForLogin, loginData);
          currentAuthToken = data.token;
          await sendRegistrationRequest(data);
        } catch (error) {
          showNotification('Não foi possível logar! Verifique suas credenciais.', 'error');
          throw error;
        }
      }
      
      async function sendRegistrationRequest(loginResponseData) {
        try {
          showNotification('Buscando redações disponíveis...', 'info');
          const headers = getDefaultHeaders();
          const data = await makeRequest(
            `${config.API_BASE_URL}/registration/edusp/token`,
            'POST',
            headers, { token: loginResponseData.token }
          );
          currentAuthToken = data.auth_token;
          userNick = data.nick;
          await fetchUserRoomsForRedacoes(data.auth_token, data.nick);
        } catch (error) {
          showNotification('Erro ao registrar informações do aluno.', 'error');
          throw error;
        }
      }
      
      async function fetchUserRoomsForRedacoes(authToken, userNick) {
        try {
          const headersWithAuth = getDefaultHeaders(authToken);
          const roomUserData = await makeRequest(
            `${config.API_BASE_URL}/room/user?list_all=true&with_cards=true`,
            'GET',
            headersWithAuth
          );
          if (roomUserData.rooms && roomUserData.rooms.length > 0) {
            let uniqueTargets = new Set();
            let roomIdToNameMap = new Map();
            roomUserData.rooms.forEach(room => {
              uniqueTargets.add(room.name);
              roomIdToNameMap.set(room.id.toString(), room.name);
              if (userNick) {
                uniqueTargets.add(`${room.name}:${userNick}`);
              }
            });
            const roomUserJsonString = JSON.stringify(roomUserData);
            const idMatches = roomUserJsonString.match(/"id"\s*:\s*(\d{3,4})(?!\d)/g) || [];
            idMatches.forEach(m => {
              const id = m.match(/\d{3,4}/)[0];
              if (id) uniqueTargets.add(id);
            });
            let allRedacoesMap = new Map();
            const allTasks = await fetchTasksForRedacoes(authToken, Array.from(uniqueTargets), ['pending', 'draft']);
            allTasks.filter(task => isRedacao(task)).forEach(task => {
              const actualStatus = task.answer_status === 'draft' ? 'draft' : 'pending';
              let roomNameForTask = '';
              if (task.publication_target) {
                if (task.publication_target.includes(':')) {
                  roomNameForTask = task.publication_target.split(':')[0];
                } else if (roomIdToNameMap.has(task.publication_target)) {
                  roomNameForTask = roomIdToNameMap.get(task.publication_target);
                } else {
                  roomNameForTask = task.publication_target;
                }
              }
              if (allRedacoesMap.has(task.id)) {
                const existingRedacao = allRedacoesMap.get(task.id);
                if (existingRedacao.status === 'draft' && actualStatus === 'pending') {
                  allRedacoesMap.set(task.id, { ...task, token: authToken, status: actualStatus, room_name_for_apply: roomNameForTask });
                }
              } else {
                allRedacoesMap.set(task.id, { ...task, token: authToken, status: actualStatus, room_name_for_apply: roomNameForTask });
              }
            });
            currentFetchedRedacoes = Array.from(allRedacoesMap.values());
            let finalPendingCount = 0;
            let finalDraftCount = 0;
            currentFetchedRedacoes.forEach(redacao => {
              if (redacao.status === 'pending') {
                finalPendingCount++;
              } else if (redacao.status === 'draft') {
                finalDraftCount++;
              }
            });
            if (currentFetchedRedacoes.length > 0) {
              displayRedacoesInSelectionModal(currentFetchedRedacoes);
              if (finalPendingCount === 0 && finalDraftCount > 0) {
                showNotification('Não foram encontradas redações pendentes, mas há redações em rascunho.', 'info');
              } else if (finalPendingCount > 0) {
                showNotification(`Você tem ${finalPendingCount} redações pendentes e ${finalDraftCount} em rascunho.`, 'info');
              } else if (finalDraftCount > 0) {
                showNotification(`Você tem ${finalDraftCount} redações em rascunho.`, 'info');
              }
            } else {
              showNotification('Nenhuma redação encontrada para o usuário.', 'info');
            }
          } else {
            showNotification('Nenhuma sala encontrada para the user.', 'info');
          }
        } catch (error) {
          showNotification('Erro ao buscar salas do usuário.', 'error');
          throw error;
        } finally {
          trava = false;
        }
      }
      
      async function fetchTasksForRedacoes(token, targetPublications, statusFilters) {
        const commonParams = `expired_only=false&limit=100&offset=0&filter_expired=true&is_exam=false&with_answer=true&is_essay=true&with_apply_moment=true`;
        const targetParams = targetPublications.map(target => {
          if (target.includes(':') && target.split(':').length === 2) {
            const [roomPart, nickPart] = target.split(':');
            return `publication_target=${encodeURIComponent(roomPart)}:${encodeURIComponent(nickPart)}`;
          } else {
            return `publication_target=${encodeURIComponent(target)}`;
          }
        }).join('&');
        const statusParams = statusFilters.map(status => `answer_statuses=${encodeURIComponent(status)}`).join('&');
        const url = `${config.API_BASE_URL}/tms/task/todo?${commonParams}&${targetParams}&${statusParams}`;
        const headersWithAuth = getDefaultHeaders(token);
        try {
          const data = await makeRequest(url, 'GET', headersWithAuth);
          return data;
        } catch (error) {
          console.error(`❌ Erro ao buscar tarefas para targets: ${targetPublications.join(', ')} e status: ${statusFilters.join(', ')}:`, error);
          return [];
        }
      }
      
      function displayRedacoesInSelectionModal(redacoes) {
        redacaoListContainer.innerHTML = '';
        if (redacoes.length === 0) {
          redacaoListContainer.innerHTML = '<p style="text-align: center; color: #c9c9c9;">Nenhuma redação encontrada.</p>';
          selectRedacaoBtn.disabled = true;
        } else {
          const sortedRedacoes = [...redacoes].sort((a, b) => {
            if (a.status === 'pending' && b.status === 'draft') return -1;
            if (a.status === 'draft' && b.status === 'pending') return 1;
            return 0;
          });
          sortedRedacoes.forEach(redacao => {
            const listItem = document.createElement('div');
            listItem.className = `task-list-checkbox`;
            const statusText = redacao.status === 'pending' ? 'Pendente' : 'Rascunho';
            const statusColor = redacao.status === 'pending' ? '#f0ad4e' : '#facc15';
            listItem.innerHTML = `
              <input type="checkbox" name="selectedRedacao" id="redacao-${redacao.id}" value="${redacao.id}">
              <label for="redacao-${redacao.id}">${redacao.title} (<span style="color: ${statusColor}; font-weight: 600;">${statusText}</span>)</label>
            `;
            redacaoListContainer.appendChild(listItem);
            const checkbox = listItem.querySelector('input[type="checkbox"]');
            checkbox.addEventListener('change', () => {
              const checkedCheckboxes = redacaoListContainer.querySelectorAll('input[type="checkbox"]:checked');
              selectRedacaoBtn.disabled = checkedCheckboxes.length === 0;
            });
          });
          selectRedacaoBtn.disabled = redacoes.length === 0;
        }
        redacaoSelectionModal.style.display = 'flex';
      }
      
      searchRedacaoBtn.addEventListener('click', async () => {
        if (trava) return;
        if (!raInput.value || !senhaInput.value) {
          showNotification('Por favor, preencha o RA e a senha.', 'warning');
          return;
        }
        trava = true;
        searchRedacaoBtn.disabled = true;
        searchRedacaoBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Buscando...';
        try {
          await loginAndFetchRedacoes();
        } catch (error) {
          console.error("Erro no processo de busca de redações:", error);
        } finally {
          trava = false;
          searchRedacaoBtn.disabled = false;
          searchRedacaoBtn.innerHTML = '<i class="fas fa-search"></i> Redação Pendente';
        }
      });
      
      closeRedacaoSelectionModalBtn.addEventListener('click', () => {
        redacaoSelectionModal.style.display = 'none';
      });

      selectRedacaoBtn.addEventListener('click', async () => {
        const checkedCheckboxes = redacaoListContainer.querySelectorAll('input[type="checkbox"]:checked');
        if (checkedCheckboxes.length > 0) {
          redacaoSelectionModal.style.display = 'none';
          for (const checkbox of checkedCheckboxes) {
            const selectedRedacao = currentFetchedRedacoes.find(r => r.id.toString() === checkbox.value);
            if (selectedRedacao) {
              await startRedactionProcess(selectedRedacao);
            }
          }
          showNotification(`Processo de redação para ${checkedCheckboxes.length} atividade(s) concluído.`, 'success');
        } else {
          showNotification('Selecione uma redação para continuar.', 'warning');
        }
      });
      
      window.addEventListener('click', (event) => {
        if (event.target === redacaoSelectionModal) {
          redacaoSelectionModal.style.display = 'none';
        }
        if (event.target === progressModal) {
          progressModal.style.display = 'none';
        }
      });
      
      function hideProgressModal() {
        progressModal.style.display = 'none';
      }
    })();
  </script>


</body></html>